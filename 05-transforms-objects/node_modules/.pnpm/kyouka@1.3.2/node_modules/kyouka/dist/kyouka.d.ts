declare const kyoka: {
    getCenterPointPos: (el: any) => import("../types/types").Point;
    getMousePos: (ev: any) => import("../types/types").Point;
    getTimeFromDate: (date: Date) => string;
    randomIntArrayInRange: (min: number, max: number, n?: number) => number[];
    randomNumberInRange: (min: number, max: number) => number;
    randomIntegerInRange: (min: number, max: number) => number;
    requestInterval: (fn: Function, delay: number) => {
        value: number;
    };
    sample: (arr: any[]) => any;
    shuffle: ([...arr]: any[]) => any[];
    sleep: (time: number) => Promise<unknown>;
    vw2px: (vw: number) => number;
    sum: (...arr: number[]) => number;
    formatDuration: (ms: number) => import("../types/types").Time;
    getTimeDeltaAsSeconds: (begin: number | Date, end: number | Date) => number;
    isPhoneNumber: (str: string) => boolean;
    isBottomVisible: (offset?: number) => boolean;
    getURLParameters: (url: string) => {};
    average: (...nums: number[]) => number;
    previewImage: (inputEl: any, imgEl: any, cb: Function) => void;
    getScrollPosition: (el?: any, unit?: string) => import("../types/types").Point;
    getScrollPositionAsVw: (el?: any) => import("../types/types").Point;
    px2vw: (px: number) => number;
    initialize2DArray: (w: number, h: number, val?: null) => any[][];
    deepClone: (obj: any) => any;
    initializeArrayWithValues: (n: number, val?: number) => any[];
    CSVToArray: (data: string, delimiter?: string, omitFirstRow?: boolean) => string[][];
    arrayToCSV: (arr: any[], delimiter?: string) => string;
    JSONToCSV: (arr: any[], columns: string[], delimiter?: string) => string;
    CSVToJSON: (data: string, delimiter?: string) => {}[];
    uniq: (arr: any[]) => any[];
    omit: (obj: any, arr: string[]) => any;
    pick: (obj: any, arr: string[]) => any;
    iosInputScrollFix: () => void;
    mapObject: (arr: [], fn: Function) => {};
    mapKeys: (obj: {}, fn: Function) => {};
    mapValues: (obj: {}, fn: Function) => {};
    isEmpty: (val: any) => boolean;
    debounce: (fn: Function, ms?: number) => (...args: any[]) => void;
    throttle: (fn: Function, wait: number) => () => void;
    partial: (fn: Function, ...partials: any[]) => (...args: any[]) => any;
    compose: (...fns: Function[]) => Function;
    curry: (fn: Function, arity?: number, ...args: any[]) => any;
    memorize: (fn: Function) => {
        (val: any): any;
        cache: Map<any, any>;
    };
    attempt: (fn: Function, ...args: any[]) => any;
    compact: (arr: any[]) => any[];
    promisify: (func: Function) => (...args: any[]) => Promise<unknown>;
    distance: (p1: import("../types/types").Point, p2: import("../types/types").Point) => number;
    zip: (...arrays: any[]) => any[][];
    range: (start: number, end: number, step?: number) => Generator<number, void, unknown>;
    unzip: (arr: any[]) => any;
    union: (a: any, b: any) => any[];
    pluck: (arr: any[], key: any) => any[];
    mask: (cc: string | number, num?: number, mask?: string) => string;
    intersection: (a: any, b: any) => unknown[];
    animateNumber: (cb: Function, from: number, to: number, duration: number) => void;
    detectDeviceType: () => "Mobile" | "Desktop";
    deg2rad: (deg: number) => number;
    factorial: (n: number) => any;
    equals: (a: any, b: any) => boolean;
    includesAll: (arr: any[], values: any[]) => boolean;
    includesAny: (arr: any[], values: any[]) => boolean;
    rad2deg: (rad: number) => number;
    randomHexColorCode: () => string;
    timeTaken: (cb: Function) => any;
    sumPower: (end: number, power?: number, start?: number) => number;
    reverseString: (str: string) => string;
    vh2px: (vh: number) => number;
    px2vh: (px: number) => number;
    loadImageAsBase64URL: (blob: any, cb: Function) => void;
    sampleSize: ([...arr]: any[], n?: number) => any[];
    fromTimestamp: (timestamp: number) => Date;
    getTimestamp: (date?: Date, floor?: boolean) => number;
    isOdd: (num: number) => boolean;
    isEven: (num: number) => boolean;
    copyToClipboard: (str: string) => void;
    yesNo: (val: string, def?: boolean) => boolean;
    loadVideoAsBlob: (file: any, cb: Function, format?: string) => void;
    maxN: (arr: [], n?: number) => never[];
    minN: (arr: [], n?: number) => never[];
    padNumber: (n: number, l: number) => string;
    addHoursToDate: (d: Date, n: number) => Date;
    addMinutesToDate: (d: Date, n: number) => Date;
    addSecondsToDate: (d: Date, n: number) => Date;
    chunk: (arr: any[], size: number) => any[][];
    isUrl: (url: string) => boolean;
    objectMap: (obj: Object, fn: Function) => {
        [k: string]: any;
    };
    orderBy: (arr: any[], props: string[], orders: string[]) => any[];
    head: (arr: any[]) => any;
    last: (arr: any[]) => any;
    objectToQueryString: (queryParameters: Object) => string;
    clamp: (num: number, lower: number, upper: number) => number;
    isElBottomVisible: (el: any, offset?: number) => boolean;
    isIdcard: (str: string) => boolean;
    lerp: (p1: number, p2: number, t: number) => number;
    maxBy: (arr: any[], fn: Function) => number;
    minBy: (arr: any[], fn: Function) => number;
    reload: () => void;
    repeatArray: (arr: [], n: number) => never[];
    degreesAngle: (p1: import("../types/types").Point, p2: import("../types/types").Point) => number;
    radiansAngle: (p1: import("../types/types").Point, p2: import("../types/types").Point) => number;
    addDaysToDate: (d: Date, n: number) => Date;
    addWeeksToDate: (d: Date, n: number) => Date;
    groupBy: (arr: any[], fn: any) => unknown;
    chunkMultiSize: (arr: any[], chunkSizes: number[]) => any[][];
    disableTouchMove: () => void;
    enableTouchMove: () => void;
    getNormalizedMousePos: (e: any) => {
        x: number;
        y: number;
    };
    dataURItoFile: (dataURI: string, filename?: string) => File;
    dateRange: (start: Date, end: Date, step?: number) => Generator<Date, void, unknown>;
    frequencies: (arr: any[]) => any;
    countOccurrences: (arr: any[], val: any) => any;
};
export default kyoka;
